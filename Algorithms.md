# 刷题笔记

[经典总结1](https://github.com/MisterBooo/LeetCodeAnimation)

## 经典问题

- #### 排序问题

  - 稳定性：两个相等的数,经过排序之后,其在序列的前后位置顺序不变，则是稳定的。
    - **稳定性排序**：冒泡排序，插入排序、归并排序、基数排序
    - **不稳定排序**：选择排序、快速排序、希尔排序、堆排序
  - 原地排序： 不占用额外内存资源的排序

- #### 卡特兰数

- #### N皇后

- #### 孤岛问题

- #### 分苹果问题

##### 问题存在两种形式，第一种是给出所有符合条件的解，这时使用递归的方法解是比较好的，另一种是让给出解的个数，这时候用数学分析的办法比较快。

> 把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？M, N为自然数。说明：如有7个苹果，2个盘子，则(5, 1, 1)和(1, 5, 1)和(1, 1, 5)都是同一种分法。
>
> 输入：
> 	第一行一个整数表示数据的组数（多组数据），对于每组数据第一行是苹果个数M (1 ≤ m ≤ 100) ，第二行是盘子个数N(1 ≤ n ≤ 100)。
> 输出：
> 	每组数据输出一行,放苹果的方法个数。

```c
// 递归的方式列出所有解
int solution(int m,int n){   
    if(m==0||n==1)    
        return 1;     
    if(n>m)  
        return fun(m,m);  //如果前面的小于后面的，则一定会有空盘子，则等于m个苹果放入m个盘子 
    else  
        return fun(m,n-1)+fun(m-n,n);  //有空盘子的情况 +　没有空盘子的情况 
} 
```



- #### 毒药问题

## 数据结构

- #### 二叉树遍历

  > 二叉树的遍历方式分为3种：前序遍历（A->B->C）、中序遍历（B->A->C）、后序遍历（B->C->A）。
  >
  > 已知前序和中序，后序和中序遍历序列之后，可以唯一确定一棵二叉树。但是，只知道前序和后序遍历序列，是无法知道哪个结点是左子树还算右子树。
  >
  > 另外的遍历方式将遍历分为深度优先遍历（DFS）和广度优先遍历（BFS）。深度优先遍历和前序遍历相似，但左右节点上没有先后顺序，此时广度优先遍历则是分层遍历，是一种自上而下的遍历方式。

  **DFS实现：**

  数据结构：栈

  父节点入栈，父节点出栈，先右子节点入栈，后左子节点入栈。递归遍历全部节点即可

  **BFS实现：**

  数据结构：队列

  父节点入队，父节点出队列，先左子节点入队，后右子节点入队。递归遍历全部节点即可

  ![1579182355860](./pic/1579182355860.png)

  - ##### 习题1

  ![1579182850479](./pic/1579182850479.png)

  > 前序遍历：ABCDEFGHK
  >
  > 中序遍历：BDCAEHGKF
  >
  > 后序遍历：DCBHKGFEA

  - ##### 习题2

- #### 平衡二叉树



- #### 其他



## 编程基础（C语言）

- ##### 输入函数

> **char *gets(char *str);** 
>
> 功能是从输入缓冲区中读取一个字符串存储到字符指针变量 str 所指向的内存空间。遇到回车后执行结束。
>
> 使用 gets() 时，系统会将最后“敲”的换行符从缓冲区中取出来，然后丢弃，所以缓冲区中不会遗留换行符。
>
> 它在执行前不会主动清除缓存空间，只是执行后才清缓存区，因此每次新接收变量前，执行getchar()。
>
> **int scanf(const char *format, ...);**
>
> 功能是从键盘输入的字符转化为“输入控制符”所规定格式的数据，然后存入以输入参数的值为地址的变量中。
>
> ```c
> // 读取含空格的字符串，遇到回车结束，并抛弃字符串中的'\n'
> scanf("%[^\n]%*c",str);
> ```
>
> 

